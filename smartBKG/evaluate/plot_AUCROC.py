#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Plot the AUCROC curve for smrt_expert generated data
# James Kahn 2018

import os
import pandas as pd
import numpy as np
from sklearn import metrics
import matplotlib.pyplot as plt

from ROOT import PyConfig
PyConfig.IgnoreCommandLineOptions = 1
import argparse  # noqa
from root_numpy import root2array  # noqa
import ROOT  # noqa


class PlotAUCROC():
    ''' Class to read ROOT files generated by smrt_expert and plot the resulting AUCROC curve '''
    def __init__(
        self,
        mdst_files,
        skim_files,
        out_dir,
        tree='tree',
        branch='EventMetaData',
        evtNum_var='m_event',
        model=None
    ):
        self.mdst_files = mdst_files
        self.skim_files = skim_files
        self.out_dir = out_dir
        self.tree = tree
        self.branch = branch
        self.evtNum_var = evtNum_var
        self.model = model

        self.true_col = 'true'

        # Build dataframes of the two files and the true/pred values
        self.mdst_df = self._build_mdst_df()
        self.skim_df = self._build_skim_df()
        self.true_pred_df = self._stitch_mdst_skim_df(mdst_df=self.mdst_df, skim_df=self.skim_df)

        # Now can calculate and plot metrics
        self._plot_metrics(
            df=self.true_pred_df,
            y_true=self.true_col,
            y_pred=self.model,
            out_dir=self.out_dir,
        )

    def _plot_metrics(self, df, y_true, out_dir, y_pred=None):
        ''' Plot the ROCAUC for y_pred column specified (or all if None) '''
        # Figure out which columns to plot
        if y_pred is None:
            y_pred = df.drop(y_true, axis=1).columns

        # Collect all models for comparison
        models = {}
        for pred_col in y_pred:
            print('Plotting model:', pred_col)
            models[pred_col] = {}
            models[pred_col]['auc'] = metrics.roc_auc_score(df[y_true], df[pred_col])
            (
                models[pred_col]['fpr'],
                models[pred_col]['tpr'],
                models[pred_col]['thresholds'],
            ) = metrics.roc_curve(df[y_true], df[pred_col])

            # Plot the single model ROC, don't need this
            # self._plot_single_model(pred_col, fpr, tpr, roc_auc, out_dir)

        self._plot_model_ROCs(models, out_dir)

    def _plot_model_ROCs(self, models_dict, out_dir):
        ''' Plot ROC of given models together '''
        out_file = os.path.join(out_dir, 'ROC_comparison.pdf')
        plt.figure(figsize=(5, 3.5))
        # plt.title('Receiver Operating Characteristic')

        for model in models_dict.keys():
            print('model:', model)
            plt.plot(
                models_dict[model]['fpr'],
                models_dict[model]['tpr'],
                'b',
                # label='{} = {:.2f}'.format(model, models_dict[model]['auc'])
                label='AUC = {:.3f}'.format(models_dict[model]['auc']),
                linewidth=1,
            )
        plt.legend(loc='best')
        plt.plot([0, 1], [0, 1], 'r--', linewidth=1)
        plt.xlim([0, 1])
        plt.ylim([0, 1])
        plt.ylabel('True Positive Rate')
        plt.xlabel('False Positive Rate')
        ax = plt.gca()
        ax.set_xticks(np.arange(0, 1, 0.1))
        ax.set_yticks(np.arange(0, 1., 0.1))
        plt.grid(linewidth=1, linestyle=':')

        plt.savefig(out_file)

    def _plot_single_model(self, model, fpr, tpr, roc_auc, out_dir):
        ''' Plot a single ROC curve to file '''
        out_file = os.path.join(out_dir, '{}_ROC.pdf'.format(model))

        # plt.title('Receiver Operating Characteristic')
        plt.plot(
            fpr,
            tpr,
            'b',
            # label='{} = {:.2f}'.format(model, roc_auc)
            label='AUC = {:.2f}'.format(roc_auc)
        )
        plt.legend(loc='best')
        plt.plot([0, 1], [0, 1], 'r--')
        plt.xlim([0, 1])
        plt.ylim([0, 1])
        plt.ylabel('True Positive Rate')
        plt.xlabel('False Positive Rate')

        plt.savefig(out_file)

    def _stitch_mdst_skim_df(self, mdst_df, skim_df):
        ''' Join the mdst and skim dfs and fill in the true vals for fail events '''
        # First check skim and mdst files match, could in theory do this earlier
        skim_index = skim_df.index.get_level_values(0).unique()
        mdst_index = mdst_df.index.get_level_values(0).unique()
        mdst_diff = mdst_index.difference(skim_index)
        skim_diff = skim_index.difference(mdst_index)
        assert len(skim_diff) == 0 and len(mdst_diff) == 0, 'Each mdst file must have a corresponding skim file'

        # Join the two dataframes
        df = pd.concat([mdst_df, skim_df], axis=1)
        # Fill in value for any events that didn't pass the skim
        df[self.true_col] = df[self.true_col].fillna(0)
        return df

    def _build_skim_df(self):
        ''' Build df of skim files with event num as index '''
        df = self._read_leaf(
            self.skim_files,
            self.tree,
            self.branch,
            self.evtNum_var,
        )
        # Add a column of the true value (pass), since it's the skim file all events are true by definition
        df[self.true_col] = 1
        return df.set_index([self.evtNum_var], append=True).reset_index(level=1, drop=True)

    def _build_mdst_df(self):
        ''' Build a df of the event nums and model predictions in MDST files '''
        evt_df = self._read_leaf(
            self.mdst_files,
            self.tree,
            self.branch,
            self.evtNum_var,
        )
        pred_df = self._read_event_extra_info(
            self.mdst_files,
            self.tree,
        )
        # Merge the event numbers and predictions
        mdst_df = pd.concat([evt_df, pred_df], axis=1)

        # Finally return the dataframe with the event numbers set as the index
        return mdst_df.set_index([self.evtNum_var], append=True).reset_index(level=1, drop=True)

    def _read_event_extra_info(self, files, tree):
        ''' Reads EventExtraInfo data from files.

        Returns df with values of each extra info as different columns
        '''
        file_dict = {}
        for f in files:
            f_base = os.path.basename(f)
            tfile = ROOT.TFile(f)
            ttree = tfile.Get(tree)
            ttree.GetEntry(0)
            eee = ttree.EventExtraInfo
            model_names = self._get_event_extra_info_vars(eee)
            file_dict[f_base] = self._build_extra_info_df(ttree, model_names)

        return pd.concat(file_dict)

    def _build_extra_info_df(self, tree, var_list):
        ''' Build dataframe containing all eventExtraInfo values '''
        eee = tree.EventExtraInfo
        vals_dict = dict.fromkeys(var_list, [])

        # Read entire tree and save variable values to arrays in a dict
        for event in range(tree.GetEntries()):
            tree.GetEntry(event)
            for var in var_list:
                vals_dict[var].append(eee.getExtraInfo(var))

        return pd.DataFrame(vals_dict)

    def _get_event_extra_info_vars(self, event_extra_info_obj):
        ''' Return a list of the names of vars in the given eventExtraInfo object '''
        # This if for pre release-02, for later can just use getNames dircelty on eee obj
        return [a.split()[0] for a in event_extra_info_obj.getInfoHTML().split('<br />') if len(a) != 0]

    def _read_leaf(self, files, tree, branch, leaf):
        ''' Read the leaf from given files and add to pandas series

        Have to use root_numpy for this, root_pandas seems to struggle with fetching leaves from branches
        '''
        file_dict = {}
        for f in files:
            # f_base = os.path.splitext(os.path.basename(f))[0]
            f_base = os.path.basename(f)
            arr = root2array(
                f,
                treename=self.tree,
                branches='{}.{}'.format(branch, leaf),
            )
            file_dict[f_base] = pd.DataFrame(arr, columns=[leaf])
        return pd.concat(file_dict)


def GetCmdArgs():
    parser = argparse.ArgumentParser(
        description='''Plot ROCAUC''',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument('-m', type=str, required=True, nargs='+',
                        help="Path to MDST files", metavar="MDST",
                        dest='mdst_files')
    parser.add_argument('-s', type=str, required=True, nargs='+',
                        help="Path to skims of MDST files", metavar="SKIM",
                        dest='skim_files')
    parser.add_argument('-t', type=str, required=False, default='tree',
                        help="Name of tree to read in ROOT files", metavar="TREE",
                        dest='tree')
    parser.add_argument('-b', type=str, required=False, default='tree',
                        help="Name of branch to read event number from in ROOT files", metavar="BRANCH",
                        dest='branch')
    parser.add_argument('-e', type=str, required=False, default='m_event',
                        help="Name of event number leaf in ROOT files", metavar="EVT_VAR",
                        dest='evt_var')
    parser.add_argument('--model', type=str, required=False, default=None, nargs='+',
                        help="Name of model to check, if not given, all present are plotted", metavar="MODEL",
                        dest='model')
    parser.add_argument('-o', type=str, required=True,
                        help="Output directory to save plot", metavar="OUTPUT",
                        dest='out_dir')
    return parser.parse_args()


if __name__ == '__main__':

    args = GetCmdArgs()
    os.makedirs(args.out_dir, exist_ok=True)

    plot_roc = PlotAUCROC(
        mdst_files=args.mdst_files,
        skim_files=args.skim_files,
        tree=args.tree,
        branch=args.branch,
        evtNum_var=args.evt_var,
        model=args.model,
        out_dir=args.out_dir,
    )
